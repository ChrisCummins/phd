"""Import dynamic features from legacy GPGPU benchmarks driver."""

import pathlib
import tempfile
import zipfile

import sqlalchemy as sql
import pandas as pd
import numpy as np

from experimental.deeplearning.clgen.closeness_to_grewe_features import \
  grewe_features_db as db
from gpu.libcecl import libcecl_runtime
from gpu.libcecl.proto import libcecl_pb2
from labm8 import app
from labm8 import fs

FLAGS = app.FLAGS

app.DEFINE_input_path(
    'gpgpu_logs_zip', None,
    'Path to the logs archive generated by legacy GPGPU benchmarks runner.')
app.DEFINE_database('db', db.Database, 'sqlite://',
                    'URL of the database to import dynamic features to.')
app.DEFINE_string('device_name', None, 'The name of the OpenCL device')
app.DEFINE_string(
    'device_type',
    None,
    'The device type. One of: {CPU, GPU}',
    validator=lambda val: val in {"CPU", "GPU"} if val else True)
app.DEFINE_string('opencl_env', None, 'The name of the OpenCL environment.')
app.DEFINE_string('hostname', None, 'The name of the hostname')


def DynamicFeaturesFromKernelInvocation(
    kernel_invocation: libcecl_pb2.OpenClKernelInvocation,
    static_features_id: int) -> db.DynamicFeatures:
  return {
      'static_features_id': static_features_id,
      'gsize': kernel_invocation.global_size,
      'wgsize': kernel_invocation.local_size,
      'transferred_bytes': kernel_invocation.transferred_bytes,
      'transfer_time_ns': kernel_invocation.transfer_time_ns,
      'kernel_time_ns': kernel_invocation.kernel_time_ns,
  }


def ImportFromLegacyGpgpu(database: db.Database, logs_zip: pathlib.Path,
                          expected_devtype: str, expected_device_name: str,
                          opencl_env: str, hostname: str) -> None:
  with database.Session() as session:
    origin_to_features_id_map = {}
    rows = []

    with tempfile.TemporaryDirectory(prefix='phd_gpgpu_') as d:
      with zipfile.ZipFile(logs_zip) as zipf:
        zipf.extractall(d)

      logs_dir = pathlib.Path(d) / 'logs'
      assert logs_dir.is_dir()

      # Directory structure of archive is:
      #     logs/<run_num>/<device_name>/<benchmark_log>.
      app.Log(1, 'Importing logs from %d runs', len(list(logs_dir.iterdir())))
      for run_dir in logs_dir.iterdir():
        for device_dir in run_dir.iterdir():
          for benchmark_log in device_dir.iterdir():
            # Re-construct the benchmark name from the file path.
            log_filename_components = benchmark_log.name.split('-')
            benchmark_suite = '-'.join(log_filename_components[:-1])
            if benchmark_suite == 'npb-3.3':
              benchmark_name, _ = log_filename_components[-1].split('.')
            else:
              benchmark_name = log_filename_components[-1]

            log_lines = fs.Read(benchmark_log).split('\n')
            kernel_invocations = libcecl_runtime.KernelInvocationsFromCeclLog(
                log_lines,
                # Legacy libcecl converted the nanoseconds returned by OpenCL API
                # to milliseconds float. See:
                # https://github.com/ChrisCummins/phd/blob/6e30717650380d7733d53984189ae579e19dc273/gpu/libcecl/libcecl.c#L153-L164
                nanosecond_identity=lambda s: int(float(s) * 1e6),
                expected_devtype=expected_devtype,
                expected_device_name=expected_device_name)

            for kernel_invocation in kernel_invocations:
              origin = (f'benchmarks_{benchmark_suite}:{benchmark_name}:'
                        f'{kernel_invocation.kernel_name}')
              app.Log(1, 'Looking up static features id for origin `%s`',
                      origin)
              if origin in origin_to_features_id_map:
                static_features_id = origin_to_features_id_map[origin]
              else:
                static_features_id = session.query(db.StaticFeatures.id) \
                    .filter(db.StaticFeatures.origin == origin).one()[0]
                origin_to_features_id_map[origin] = static_features_id

              rows.append(
                  DynamicFeaturesFromKernelInvocation(kernel_invocation,
                                                      static_features_id))

    df = pd.DataFrame(rows)

    # Aggregate runtimes and append run_count.
    groupby_columns = ['static_features_id', 'gsize', 'wgsize']
    run_counts = df.groupby(groupby_columns).count()['kernel_time_ns']
    df = df.groupby(groupby_columns).mean()
    df['run_count'] = run_counts
    df.reset_index(inplace=True)

    # Add missing columns.
    df['static_features_id'] = static_features_id
    df['driver'] = db.DynamicFeaturesDriver.LIBCECL
    df['outcome'] = 'PASS'
    df['opencl_env'] = opencl_env
    df['hostname'] = hostname

    df.to_sql(
        db.DynamicFeatures.__tablename__,
        con=database.engine,
        if_exists='append',
        index=False,
        dtype={'driver': sql.Enum(db.DynamicFeaturesDriver)})


def main():
  """Main entry point."""
  ImportFromLegacyGpgpu(
      FLAGS.db(),
      FLAGS.gpgpu_logs_zip,
      expected_devtype=FLAGS.device_type,
      expected_device_name=FLAGS.device_name,
      opencl_env=FLAGS.opencl_env,
      hostname=FLAGS.hostname)


if __name__ == '__main__':
  app.Run(main)
