"""Utility code for working with LLVM."""

import multiprocessing
import pathlib
import re
import tempfile
import typing

import pydot
import pyparsing
from absl import app
from absl import flags

from compilers.llvm import opt
from experimental.compilers.reachability import control_flow_graph as cfg
from labm8 import fs


FLAGS = flags.FLAGS


def DotCfgsFromBytecode(
    bytecode: str) -> typing.Iterator[str]:
  """Create a control flow graph from an LLVM bytecode file.

  Args:
    bytecode: The LLVM bytecode to create CFG dots from.

  Returns:
    An iterator of dotfile strings.

  Raises:
    OptException: In case the opt pass fails.
    UnicodeDecodeError: If generated dotfile can't be read.
  """
  with tempfile.TemporaryDirectory(prefix='phd_') as d:
    output_dir = pathlib.Path(d)
    # Change into the output directory, because the -dot-cfg pass writes files
    # to the current working directory.
    with fs.chdir(output_dir):
      # We run with universal_newlines=False because the stdout of opt is the
      # binary bitcode, which we completely ignore (we're only interested in
      # stderr). This means we must encode stdin and decode stderr ourselves.
      process = opt.Exec(['-dot-cfg'], stdin=bytecode.encode('utf-8'),
                         universal_newlines=False)
      stderr = process.stderr.decode('utf-8')

      # Propagate failures from opt as OptExceptions.
      if process.returncode:
        raise opt.OptException(
            f"opt failed with return code {process.returncode}:\n{stderr}")

      for file in output_dir.iterdir():
        # Opt pass prints the name of the dot files it generates, e.g.:
        #
        #     $ opt -dot-cfg < foo.ll
        #     WARNING: You're attempting to print out a bitcode file.
        #     This is inadvisable as it may cause display problems. If
        #     you REALLY want to taste LLVM bitcode first-hand, you
        #     can force output with the `-f' option.
        #
        #     Writing 'cfg.DoSomething.dot'...
        #     Writing 'cfg.main.dot'...
        if f"Writing '{file.name}'..." not in stderr:
          raise OSError(f"Could not find reference to file '{file.name}' in "
                        f"opt stderr:\n{process.stderr}")
        with open(file) as f:
          yield f.read()


def NodeAttributesToBasicBlock(
    node_attributes: typing.Dict[str, str]) -> typing.Dict[str, str]:
  """Get the basic block graph node attributes from a dot graph node.

  Args:
    node_attributes: The dictionary of dot graph information.

  Returns:
    A dictionary of node attributes.
  """
  label = node_attributes.get('label', '')
  if not label.startswith('"{'):
    raise ValueError(f"Unhandled label: '{label}'")
  # Lines are separated using '\l' in the dot label.
  lines = label.split('\l')
  return {
    # The name is in the first line.
    'name': lines[0][len('"{'):].split(':')[0],
    # All other lines except the last contain instructions.
    'text': '\n'.join(x.lstrip() for x in lines[1:-1]),
  }


class LlvmControlFlowGraph(cfg.ControlFlowGraph):
  """A subclass of the generic control flow graph for LLVM CFGs."""
  pass


def ControlFlowGraphFromDotSource(
    dot_source: str) -> LlvmControlFlowGraph:
  """Create a control flow graph from an LLVM-generated dot file.

  The control flow graph generated from the dot source is not guaranteed to
  be valid. That is, it may contain fusible basic blocks. This can happen if
  the creating the graph from unoptimized bytecode. To disable this generate
  the bytecode with optimizations enabled, e.g. clang -emit-llvm -O3 -S ...

  Args:
    dot_source: The dot source generated by the LLVM -dot-cfg pass.

  Returns:
    A ControlFlowGraph instance.

  Raises:
    pyparsing.ParseException: If dotfile could not be parsed.
    ValueError: If dotfile could not be interpretted / is malformed.
  """
  try:
    parsed_dots = pydot.graph_from_dot_data(dot_source)
  except TypeError as e:
    raise pyparsing.ParseException("Failed to parse dot source") from e

  if len(parsed_dots) != 1:
    raise ValueError(f"Expected 1 Dot in source, found {len(parsed_dots)}")

  dot = parsed_dots[0]

  graph_re_match = re.match(r"\"CFG for '(\w+)' function\"", dot.get_name())
  if not graph_re_match:
    raise ValueError(f"Could not interpret graph name '{dot.get_name()}'")

  # Create the ControlFlowGraph instance.
  graph = LlvmControlFlowGraph(name=graph_re_match.group(1))

  # Create the nodes and build a map from node names to indices.
  node_name_to_index_map = {}
  for i, node in enumerate(dot.get_nodes()):
    if node.get_name() in node_name_to_index_map:
      raise ValueError(f"Duplicate node name! '{node.get_name()}'")
    node_name_to_index_map[node.get_name()] = i
    graph.add_node(i, **NodeAttributesToBasicBlock(node.get_attributes()))

  def NodeIndex(node: pydot.Node) -> int:
    """Get the index of a node."""
    return node_name_to_index_map[node.get_name()]

  first_node_name = sorted(node_name_to_index_map.keys())[0]
  entry_block = dot.get_node(first_node_name)[0]
  graph.nodes[NodeIndex(entry_block)]['entry'] = True

  def IsExitNode(node: pydot.Node) -> bool:
    """Determine if the given node is an exit block.

    In LLVM bytecode, an exit block is one in which the final instruction begins
    with 'ret '. There should be only one exit block per graph.
    """
    label = node.get_attributes().get('label', '')
    # Node labels use \l to escape newlines.
    label_lines = label.split('\l')
    # The very last line is just a closing brace.
    last_line_with_instructions = label_lines[-2]
    return last_line_with_instructions.lstrip().startswith('ret ')

  # Set the exit node.
  exit_nodes = []
  for node in dot.get_nodes():
    if IsExitNode(node):
      exit_nodes.append(node)

  if len(exit_nodes) != 1:
    raise ValueError("Couldn't find an exit block")

  graph.nodes[NodeIndex(exit_nodes[0])]['exit'] = True

  for edge in dot.get_edges():
    # In the dot file, an edge looks like this:
    #     Node0x7f86c670c590:s0 -> Node0x7f86c65001a0;
    # We split the :sX suffix from the source to get the node name.
    # TODO(cec): We're currently throwing away the subrecord information and
    # True/False labels on edges. We may want to preserve that here.
    src = node_name_to_index_map[edge.get_source().split(':')[0]]
    dst = node_name_to_index_map[edge.get_destination()]
    graph.add_edge(src, dst)

  return graph


class DotCfgsFromBytecodeError(ValueError):
  """An error raised processing a bytecode file."""

  def __init__(self, bytecode: str, error: Exception):
    self.input = bytecode
    self.error = error


class ControlFlowGraphFromDotSourceError(ValueError):
  """An error raised processing a dot source."""

  def __init__(self, dot: str, error: Exception):
    self.input = dot
    self.error = error


def _DotCfgsFromBytecodeToQueue(bytecode: str,
                                queue: multiprocessing.Queue) -> None:
  """Process a bytecode and submit the dot source or the exception."""
  try:
    queue.put(list(DotCfgsFromBytecode(bytecode)))
  except Exception as e:
    queue.put(DotCfgsFromBytecodeError(bytecode, e))


def _ControlFlowGraphFromDotSourceToQueue(dot: str,
                                          queue: multiprocessing.Queue) -> None:
  """Process a dot source and submit the CFG or the exception."""
  try:
    queue.put(ControlFlowGraphFromDotSource(dot))
  except Exception as e:
    queue.put(ControlFlowGraphFromDotSourceError(dot, e))


class ExceptionBuffer(Exception):
  """A meta-exception that is used to buffer multiple errors to be raised."""

  def __init__(self, errors):
    self.errors = errors


def ControlFlowGraphsFromBytecodes(
    bytecodes: typing.Iterator[str]) -> typing.Iterator[cfg.ControlFlowGraph]:
  dot_processes = []
  dot_queue = multiprocessing.Queue()
  for bytecode in bytecodes:
    process = multiprocessing.Process(target=_DotCfgsFromBytecodeToQueue,
                                      args=(bytecode, dot_queue))
    process.start()
    dot_processes.append(process)

  cfg_processes = []
  cfg_queue = multiprocessing.Queue()

  e = ExceptionBuffer([])

  for _ in range(len(dot_processes)):
    dots = dot_queue.get()
    if isinstance(dots, Exception):
      e.errors.append(dots)
    else:
      for dot in dots:
        process = multiprocessing.Process(
            target=_ControlFlowGraphFromDotSourceToQueue, args=(dot, cfg_queue))
        process.start()
        cfg_processes.append(process)

  # Get the graphs generated by the CFG processes.
  for _ in range(len(cfg_processes)):
    graph = cfg_queue.get()
    if isinstance(graph, Exception):
      e.errors.append(graph)
    else:
      yield graph

  # Make sure that all processes have terminated. They will have, but best to
  # check.
  [p.join() for p in dot_processes]
  [p.join() for p in cfg_processes]

  if e.errors:
    raise e


def main(argv):
  """Main entry point."""
  if len(argv) > 1:
    raise app.UsageError("Unknown arguments: '{}'.".format(' '.join(argv[1:])))


if __name__ == '__main__':
  app.run(main)
