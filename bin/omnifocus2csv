#!/usr/bin/env python3.6

import spreadsheet

import csv
import datetime
import json
import logging
import os
import re

from argparse import ArgumentParser, FileType
from collections import defaultdict
from tempfile import TemporaryDirectory
from zipfile import ZipFile
from xml.dom import minidom


def count_tasks(count, data, complete: bool):
    if isinstance(data, list):
        for node in data:
            count = count_tasks(count, node, complete)
    else:
        if "completed" in data:
            count += 1 if data["completed"] == complete else 0
        for node in data:
            if isinstance(data[node], list) or isinstance(data[node], dict):
                count = count_tasks(count, data[node], complete)
    return count


def _get_tasks(tasks, data):
    if isinstance(data, list):
        for node in data:
            _get_tasks(tasks, node)
    else:
        if "dateAdded" in data and "completionDate" in data:
            if data["dateAdded"]:
                tasks.append((data["dateAdded"], data["completionDate"], data["name"]))
        for node in data:
            if isinstance(data[node], list) or isinstance(data[node], dict):
                _get_tasks(tasks, data[node])
    return tasks


def _get_task(task):
    started, completed, name = task
    if started:
        started = datetime.datetime.utcfromtimestamp(started / 1000)
    if completed:
        completed = datetime.datetime.utcfromtimestamp(completed / 1000)
    return started, completed, name


def get_tasks(data):
    tasks = _get_tasks([], data)
    tasks = [_get_task(x) for x in sorted(tasks, key=lambda x: x[0])]
    return tasks


def daterange(start_date, end_date):
    for n in range(int((end_date - start_date).days)):
        yield start_date + datetime.timedelta(n)


def task_count(tasks, date, completed: bool):
    count = 0
    for task in tasks:
        # count complete and incomplete tasks:
        if completed and task[1] and task[1].date() <= date:
            count += 1
        elif not completed and task[0] and task[0].date() <= date:
            count += 1
    return count


def process_json(infile, outdir):
    try:
        os.mkdir(outdir)
    except FileExistsError:
        pass

    logging.debug(f"Parsing {infile.name}")
    data = json.load(infile)

    completed = count_tasks(0, data, complete=True)
    incomplete = count_tasks(1, data, complete=False)

    tasks = get_tasks(data)
    start = tasks[0][0].date()
    today = datetime.date.today()

    with open(f"{outdir}/OmniFocus Tasks.csv", "w") as outfile:
        writer = csv.writer(outfile, delimiter=",", quoting=csv.QUOTE_MINIMAL)

        # Write header
        writer.writerow(["Date", "Total Incomplete", "Total Complete",
                         "Tasks Added", "Tasks Completed", "Tasks Delta"])

        last_incomplete, last_complete = 0, 0

        for date in daterange(start, today):
            incomplete = task_count(tasks, date, completed=False)
            complete = task_count(tasks, date, completed=True)
            delta_added = incomplete - last_incomplete
            delta_completed = complete - last_complete
            delta = delta_added - delta_completed
            writer.writerow([date, incomplete, complete,
                             delta_added, delta_completed, delta])
            last_incomplete = incomplete
            last_complete = complete

        nrows = len(tasks)
        logging.info(f"Exported {nrows} records to \"{outfile.name}\"")


def main():
    parser = ArgumentParser()
    parser.add_argument("infile", metavar="<json>", type=FileType('r'),
                        help="Path to JSON OmniFocus export")
    parser.add_argument("outdir", metavar="<dir>",
                        help="Path to output CSV files")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="enable more verbose logging output")
    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    else:
        logging.getLogger().setLevel(logging.INFO)
    logging.basicConfig(format="%(message)s")

    process_json(args.infile, args.outdir)


if __name__ == "__main__":
    main()
