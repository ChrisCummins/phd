\newsavebox{\NvidiaStreamClusterInput}
\begin{lrbox}{\NvidiaStreamClusterInput}
  \begin{minipage}{\textwidth}
    \begin{minted}{opencl_lexer.py:OpenCLLexer -x}
//#define Elements
kernel void memset_kernel(global char * mem_d, short val, int number_bytes){
    const int thread_id = get_global_id(0);
    mem_d[thread_id] = val;
}
    \end{minted}
  \end{minipage}
\end{lrbox}

\newsavebox{\NvidiaStreamClusterOutput}
\begin{lrbox}{\NvidiaStreamClusterOutput}
  \begin{minipage}{\textwidth}
    \begin{minted}{opencl_lexer.py:OpenCLLexer -x}
kernel void A(global char* a, short b, int c) {
  const int d = get_global_id(0);
  a[d] = b;
}
    \end{minted}
  \end{minipage}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[%
    An example, short OpenCL kernel, taken from Nvidia's \emph{streamcluster}.%
  ]{\noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaStreamClusterInput}}}}\\%
  \subfloat[%
    The \emph{streamcluster} kernel after source rewriting. Variable and
    function names are normalised, comments removed, and code style enforced.%
  ]{\noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaStreamClusterOutput}}}}\\%
  \subfloat[%
    Derived vocabulary, ordered by their appearance in the
    input~\protect\subref{subfig:source_out}. The vocabulary maps tokens to
    integer indices.%
  ]{%
    \input{tab/vocabulary}%
    \label{subfig:source_vocab}%
  }\\%
  \subfloat[%
    Indices encoded kernel sequence. Sequences may be padded to a fixed length
    by repeating an out-of-vocabulary integer (e.g. -1).%
  ]{%
    \input{tab/encoded}%
    \label{subfig:source_enc}%
  }%
  \caption[Deriving a vocabulary encoding from an OpenCL source code]{%
    Deriving a tokenised $1$-of-$k$ vocabulary encoding from an OpenCL source
    code.%
  }%
  \label{fig:encoding}%
\end{figure}
